# THIS FILE CONTAINS PORTIONS COPIED FROM:

#   bash_completion - programmable completion functions for bash 3.x
#   http://bash-completion.alioth.debian.org/
#   RELEASE: 20080617.5

if [[ $- == *v* ]]; then
	BASH_COMPLETION_ORIGINAL_V_VALUE="-v"
else
	BASH_COMPLETION_ORIGINAL_V_VALUE="+v"
fi

if [[ -n $BASH_COMPLETION_DEBUG ]]; then
	set -v
else
	set +v
fi

# Alter the following to reflect the location of this file.
#
[ -n "$BASH_COMPLETION" ] || BASH_COMPLETION=/etc/bash_completion
[ -n "$BASH_COMPLETION_DIR" ] || BASH_COMPLETION_DIR=/etc/bash_completion.d
readonly BASH_COMPLETION BASH_COMPLETION_DIR

# Set a couple of useful vars
#
UNAME=$( uname -s )
# strip OS type and version under Cygwin (e.g. CYGWIN_NT-5.1 => Cygwin)
UNAME=${UNAME/CYGWIN_*/Cygwin}
RELEASE=$( uname -r )

# features supported by bash 2.05 and higher
if [ ${BASH_VERSINFO[0]} -eq 2 ] && [[ ${BASH_VERSINFO[1]} > 04 ]] ||
   [ ${BASH_VERSINFO[0]} -gt 2 ]; then
	declare -r bash205=$BASH_VERSION 2>/dev/null || :
	default="-o default"
	dirnames="-o dirnames"
	filenames="-o filenames"
fi
# features supported by bash 2.05b and higher
if [ ${BASH_VERSINFO[0]} -eq 2 ] && [[ ${BASH_VERSINFO[1]} = "05b" ]] ||
   [ ${BASH_VERSINFO[0]} -gt 2 ]; then
	declare -r bash205b=$BASH_VERSION 2>/dev/null || :
	nospace="-o nospace"
fi
# features supported by bash 3.0 and higher
if [ ${BASH_VERSINFO[0]} -gt 2 ]; then
	declare -r bash3=$BASH_VERSION 2>/dev/null || :
	bashdefault="-o bashdefault"
	plusdirs="-o plusdirs"
fi
# start of section containing completion functions called by other functions

# This function checks whether we have a given program on the system.
# No need for bulky functions in memory if we don't.
#
have()
{
	unset -v have
	PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin type $1 &>/dev/null &&
		have="yes"
}

# use GNU sed if we have it, since its extensions are still used in our code
#
[ $UNAME != Linux ] && have gsed && alias sed=gsed

# This function checks whether a given readline variable
# is `on'.
#
_rl_enabled()
{
    [[ "$( bind -v )" = *$1+([[:space:]])on* ]]
}

# This function shell-quotes the argument
quote()
{
	echo \'${1//\'/\'\\\'\'}\' #'# Help vim syntax highlighting
}

# This function quotes the argument in a way so that readline dequoting 
# results in the original argument
quote_readline()
{
	local t="${1//\\/\\\\}"
	echo \'${t//\'/\'\\\'\'}\' #'# Help vim syntax highlighting
}

# This function shell-dequotes the argument
dequote()
{
	eval echo "$1"
}

# Get the word to complete
# This is nicer than ${COMP_WORDS[$COMP_CWORD]}, since it handles cases
# where the user is completing in the middle of a word.
# (For example, if the line is "ls foobar",
# and the cursor is here -------->   ^
# it will complete just "foo", not "foobar", which is what the user wants.)
#
#
# Accepts an optional parameter indicating which characters out of
# $COMP_WORDBREAKS should NOT be considered word breaks. This is useful
# for things like scp where we want to return host:path and not only path.
_get_cword()
{
	if [[ "${#COMP_WORDS[COMP_CWORD]}" -eq 0 ]] || [[ "$COMP_POINT" == "${#COMP_LINE}" ]]; then
		echo "${COMP_WORDS[COMP_CWORD]}"
	else
		local i
		local cur="$COMP_LINE"
		local index="$COMP_POINT"
		for (( i = 0; i <= COMP_CWORD; ++i )); do
			while [[ "${#cur}" -ge ${#COMP_WORDS[i]} ]] && [[ "${cur:0:${#COMP_WORDS[i]}}" != "${COMP_WORDS[i]}" ]]; do
				cur="${cur:1}"
				index="$(( index - 1 ))"
			done
			if [[ "$i" -lt "$COMP_CWORD" ]]; then
				local old_size="${#cur}"
				cur="${cur#${COMP_WORDS[i]}}"
				local new_size="${#cur}"
				index="$(( index - old_size + new_size ))"
			fi
		done
		
		if [[ "${COMP_WORDS[COMP_CWORD]:0:${#cur}}" != "$cur" ]]; then
			# We messed up! At least return the whole word so things 
			# keep working
			echo "${COMP_WORDS[COMP_CWORD]}"
		else
			echo "${cur:0:$index}"
		fi
	fi
}

# This function performs file and directory completion. It's better than
# simply using 'compgen -f', because it honours spaces in filenames.
# If passed -d, it completes only on directories. If passed anything else,
# it's assumed to be a file glob to complete on.
#
_filedir()
{
	local IFS=$'\t\n' xspec

	_expand || return 0

	local toks=( ) tmp
	while read -r tmp; do
		[[ -n $tmp ]] && toks[${#toks[@]}]=$tmp
	done < <( compgen -d -- "$(quote_readline "$cur")" )
	
	if [[ "$1" != -d ]]; then
		xspec=${1:+"!*.$1"}
		while read -r tmp; do
			[[ -n $tmp ]] && toks[${#toks[@]}]=$tmp
		done < <( compgen -f -X "$xspec" -- "$(quote_readline "$cur")" )
	fi

	COMPREPLY=( "${COMPREPLY[@]}" "${toks[@]}" )
}

# This function expands tildes in pathnames
#
_expand()
{
	# FIXME: Why was this here?
	#[ "$cur" != "${cur%\\}" ] && cur="$cur\\"

	# expand ~username type directory specifications
	if [[ "$cur" == \~*/* ]]; then
		eval cur=$cur
	elif [[ "$cur" == \~* ]]; then
		cur=${cur#\~}
		COMPREPLY=( $( compgen -P '~' -u $cur ) )
		return ${#COMPREPLY[@]}
	fi
}

_remove_comp_word()
{
	if [[ COMP_CWORD -eq 0 ]]; then
		return
	elif [[ ${#COMP_WORDS[@]} -ge 2 ]]; then
		local old_cw0="${COMP_WORDS[0]}"
		local new_cw0="${COMP_WORDS[1]}"
		local old_length="${#COMP_LINE}"
		COMP_LINE=${COMP_LINE#${old_cw0}}
		local head=${COMP_LINE:0:${#new_cw0}}
		local i=1
		while [[ $head != $new_cw0 ]]; do
			COMP_LINE=${COMP_LINE:1}
			head=${COMP_LINE:0:${#new_cw0}}
			if (( ++i > 10 )); then
				break
			fi
		done
		local new_length="${#COMP_LINE}"
		COMP_POINT=$(( COMP_POINT + new_length - old_length ))
		
		COMP_CWORD=$(( COMP_CWORD - 1 ))
		for (( i=0; i < ${#COMP_WORDS[@]} - 1; ++i )); do
			COMP_WORDS[i]="${COMP_WORDS[i+1]}"
		done
		unset COMP_WORDS[${#COMP_WORDS[@]}-1]
	else
		return
	fi
}

# cvs(1) completion
#
have cvs && {
set_prefix()
{
	[ -z ${prefix:-} ] || prefix=${cur%/*}/
	[ -r ${prefix:-}CVS/Entries ] || prefix=""
}

get_entries()
{
	local IFS=$'\n'
	[ -r ${prefix:-}CVS/Entries ] && \
	entries=$(cut -d/ -f2 -s ${prefix:-}CVS/Entries)
}

get_modules()
{
	if [ -n "$prefix" ]; then
		COMPREPLY=( $( command ls -d ${cvsroot}/${prefix}/!(CVSROOT) ) )
	else
		COMPREPLY=( $( command ls -d ${cvsroot}/!(CVSROOT) ) )
	fi
}

_cvs()
{
	local cur count mode i cvsroot cvsroots pwd
	local -a flags miss files entries changed newremoved

	COMPREPLY=()
	cur=`_get_cword`

	count=0
	for i in "${COMP_WORDS[@]}"; do
		[ $count -eq $COMP_CWORD ] && break
		# Last parameter was the CVSROOT, now go back to mode selection
		if [ "${COMP_WORDS[((count))]}" == "$cvsroot" -a "$mode" == "cvsroot" ]; then
			mode=""
		fi
		if [ -z "$mode" ]; then
			case $i in
			-d)
				mode=cvsroot
				cvsroot=${COMP_WORDS[((count+1))]}
				;;
			@(ad?(d)|new))
				mode=add
				;;
			@(adm?(in)|rcs))
				mode=admin
				;;
			ann?(notate))
				mode=annotate
				;;
			@(checkout|co|get))
				mode=checkout
				;;
			@(com?(mit)|ci))
				mode=commit
				;;
			di?(f?(f)))
				mode=diff
				;;
			ex?(p?(ort)))
				mode=export
				;;
			?(un)edit)
				mode=$i
				;;
			hi?(s?(tory)))
				mode=history
				;;
			im?(p?(ort)))
				mode=import
				;;
			re?(l?(ease)))
				mode=release
				;;
			?(r)log)
				mode=log
				;;
			@(rdiff|patch))
				mode=rdiff
				;;
			@(remove|rm|delete))
				mode=remove
				;;
			@(rtag|rfreeze))
				mode=rtag
				;;
			st?(at?(us)))
				mode=status
				;;
			@(tag|freeze))
				mode=tag
				;;
			up?(d?(ate)))
				mode=update
				;;
			*)
				;;
			esac
		elif [[ "$i" = -* ]]; then
			flags=( "${flags[@]}" $i )
		fi
		count=$((++count))
	done

	case "$mode" in
	add)
		if [[ "$cur" != -* ]]; then
			set_prefix
			if [ $COMP_CWORD -gt 1 -a -r ${prefix:-}CVS/Entries ]; then
				get_entries
				[ -z "$cur" ] && \
				files=$( command ls -Ad !(CVS) ) || \
				files=$( command ls -d ${cur}* 2>/dev/null )
				for i in "${entries[@]}"; do
					files=( ${files[@]/#$i//} )
				done
				COMPREPLY=( $( compgen -W '${files[@]}' -- \
					       $cur ) )
			fi
		else
			COMPREPLY=( $( compgen -W '-k -m' -- $cur ) )
		fi
		;;
	admin)
		if [[ "$cur" = -* ]]; then
			COMPREPLY=( $( compgen -W '-i -a -A -e -b -c -k -l -u \
						   -L -U -m -M -n -N -o -q -I \
						   -s -t -t- -T -V -x -z' -- \
					$cur ) )
		fi
		;;
	annotate)
		if [[ "$cur" = -* ]]; then
			COMPREPLY=( $( compgen -W '-D -F -f -l -R -r' -- $cur ) )
		else
			get_entries
			COMPREPLY=( $( compgen -W '${entries[@]}' -- $cur ) )
		fi
		;;
	checkout)
		if [[ "$cur" != -* ]]; then
			[ -z "$cvsroot" ] && cvsroot=$CVSROOT
			COMPREPLY=( $( cvs -d "$cvsroot" co -c 2> /dev/null | \
					awk '{print $1}' ) )
			COMPREPLY=( $( compgen -W '${COMPREPLY[@]}' -- $cur ) )
		else
			COMPREPLY=( $( compgen -W '-A -N -P -R -c -f -l -n -p \
						  -s -r -D -d -k -j' -- $cur ) )
		fi
		;;
	commit)
		set_prefix

		if [[ "$cur" != -* ]] && [ -r ${prefix:-}CVS/Entries ]; then
			# if $COMP_CVS_REMOTE is not null, 'cvs commit' will
			# complete on remotely checked-out files (requires
			# passwordless access to the remote repository
			if [ -n "${COMP_CVS_REMOTE:-}" ]; then
				# this is the least computationally intensive
				# way found so far, but other changes
				# (something other than changed/removed/new)
				# may be missing
				changed=( $( cvs -q diff --brief 2>&1 | \
				sed -ne 's/^Files [^ ]* and \([^ ]*\) differ$/\1/p' ) )
				newremoved=( $( cvs -q diff --brief 2>&1 | \
				sed -ne 's/^cvs diff: \([^ ]*\) .*, no comparison available$/\1/p' ) )
				COMPREPLY=( $( compgen -W '${changed[@]:-} \
						   ${newremoved[@]:-}' -- $cur ) )
			else
				_filedir
			fi
		else
			COMPREPLY=( $( compgen -W '-n -R -l -f -F -m -r' -- \
				       $cur ) )
		fi
		;;
	cvsroot)
		if [ -r ~/.cvspass ]; then
			# Ugly escaping because of bash treating ':' specially
			cvsroots=$( sed 's/^[^ ]* //; s/:/\\:/g' ~/.cvspass )
			COMPREPLY=( $( compgen -W '$cvsroots' -- $cur ) )
		fi
		;;
	export)
		if [[ "$cur" != -* ]]; then
			[ -z "$cvsroot" ] && cvsroot=$CVSROOT
			COMPREPLY=( $( cvs -d "$cvsroot" co -c | awk '{print $1}' ) )
			COMPREPLY=( $( compgen -W '${COMPREPLY[@]}' -- $cur ) )
		else
			COMPREPLY=( $( compgen -W '-N -f -l -R -n \
						  -r -D -d -k' -- $cur ) )
		fi
		;;
	diff)
		if [[ "$cur" == -* ]]; then
			_longopt diff
		else
			get_entries
			COMPREPLY=( $( compgen -W '${entries[@]:-}' -- $cur ) )
		fi
		;;
	remove)
		if [[ "$cur" != -* ]]; then
			set_prefix
			if [ $COMP_CWORD -gt 1 -a -r ${prefix:-}CVS/Entries ]; then
				get_entries
				# find out what files are missing
				for i in "${entries[@]}"; do
					[ ! -r "$i" ] && miss=( "${miss[@]}" $i )
				done
				COMPREPLY=( $(compgen -W '${miss[@]:-}' -- $cur) )
			fi
		else
			COMPREPLY=( $( compgen -W '-f -l -R' -- $cur ) )
		fi
		;;
	import)
		if [[ "$cur" != -* ]]; then
			# starts with same algorithm as checkout
			[ -z "$cvsroot" ] && cvsroot=$CVSROOT
			prefix=${cur%/*}
			if [ -r ${cvsroot}/${prefix} ]; then
				get_modules
				COMPREPLY=( ${COMPREPLY[@]#$cvsroot} )
				COMPREPLY=( ${COMPREPLY[@]#\/} )
			fi
			pwd=$( pwd )
			pwd=${pwd##*/}
			COMPREPLY=( $( compgen -W '${COMPREPLY[@]} $pwd' -- \
				       $cur ) )
		else
			COMPREPLY=( $( compgen -W '-d -k -I -b -m -W' -- $cur ))
		fi
		;;
	update)
		if [[ "$cur" = -* ]]; then
			COMPREPLY=( $( compgen -W '-A -P -C -d -f -l -R -p \
						   -k -r -D -j -I -W' -- \
						   $cur ) )
		fi
		;;
	"")
		COMPREPLY=( $( compgen -W 'add admin annotate checkout ci co \
					   commit diff delete edit export \
					   freeze get history import log new \
					   patch rcs rdiff release remove \
					   rfreeze rlog rm rtag stat status \
					   tag unedit up update -H -Q -q -b \
					   -d -e -f -l -n -t -r -v -w -x -z \
					   --help --version' -- $cur ) )
		;;
	*)
		;;
	esac

	return 0
}
complete -F _cvs $default cvs
}

# GNU make(1) completion
#
have make || have gmake || have gnumake || have pmake &&
_make()
{
	local file makef makef_dir="." makef_inc cur prev i

	COMPREPLY=()
	cur=`_get_cword`
	prev=${COMP_WORDS[COMP_CWORD-1]}

	# --name value style option
	case $prev in
		-@(f|o|W))
			_filedir
			return 0
			;;
		-@(I|C))
			_filedir -d
			return 0
			;;
	esac

	# --name=value style option
	if [[ "$cur" == *=* ]]; then
		prev=${cur/=*/}
		cur=${cur/*=/}
		case "$prev" in
			--@(file|makefile))
				_filedir
				return 0
				;;
			--@(directory|include-dir))
				_filedir -d
				return 0
				;;
		esac
	fi

	if [[ "$cur" == -* ]]; then
		COMPREPLY=( $( compgen -W '-b -m -B -C -d -e -f -h -i -I\
			-j -l -k -n -o -p -q -r -R - s -S -t -v -w -W \
			--always-make --directory= --debug \
			--environment-overrides --file= --makefile= --help \
			--ignore-errors --include-dir= --jobs --load-average \
			--max-load --keep-going --just-print --dry-run \
			--recon --old-file= --assume-old= --print-data-base \
			--question --no-builtin-rules --no-builtin-variables \
			--silent --quiet --no-keep-goind --stop --touch \
			--version --print-directory --no-print-directory \
			--what-if= --new-file= --assume-new= \
			--warn-undefined-variables' -- $cur ) )
	else
		# before we check for makefiles, see if a path was specified
		# with -C
		for (( i=0; i < ${#COMP_WORDS[@]}; i++ )); do
			if [[ ${COMP_WORDS[i]} == -C ]]; then
				# eval for tilde expansion
				eval makef_dir=${COMP_WORDS[i+1]}
				break
			fi
		done

		# make reads `GNUmakefile', then `makefile', then `Makefile'
		if [ -f ${makef_dir}/GNUmakefile ]; then
			makef=${makef_dir}/GNUmakefile
		elif [ -f ${makef_dir}/makefile ]; then
			makef=${makef_dir}/makefile
		elif [ -f ${makef_dir}/Makefile ]; then
			makef=${makef_dir}/Makefile
		else
			makef=${makef_dir}/*.mk	       # local convention
		fi

		# before we scan for targets, see if a Makefile name was
		# specified with -f
		for (( i=0; i < ${#COMP_WORDS[@]}; i++ )); do
			if [[ ${COMP_WORDS[i]} == -f ]]; then
				# eval for tilde expansion
				eval makef=${COMP_WORDS[i+1]}
				break
			fi
		done

		[ ! -f $makef ] && return 0

		# deal with included Makefiles
 		makef_inc=$( grep -E '^-?include' $makef | sed -e "s,^.* ,"$makef_dir"/," )

 		for file in $makef_inc; do
 			[ -f $file ] && makef="$makef $file"
 		done

		COMPREPLY=( $( awk -F':' '/^[a-zA-Z0-9][^$#\/\t=]*:([^=]|$)/ \
				{split($1,A,/ /);for(i in A)print A[i]}' \
				$makef 2>/dev/null | command grep "^$cur" ))
	fi
} &&
complete -f -F _make $filenames make gmake gnumake pmake

# A meta-command completion function for commands like sudo(8), which need to
# first complete on a command, then complete according to that command's own
# completion definition - currently not quite foolproof (e.g. mount and umount
# don't work properly), but still quite useful.
#
_command()
{
	local cur func cline cspec noglob cmd done i \
	      _COMMAND_FUNC _COMMAND_FUNC_ARGS

	_remove_comp_word
	COMPREPLY=()
	cur=`_get_cword`
	# If the the first arguments following our meta-command-invoker are
	# switches, get rid of them. Most definitely not foolproof.
	done=
	while [ -z $done ] ; do
		cmd=${COMP_WORDS[0]}
		if [[ "$cmd" == -* ]] && [[ $COMP_CWORD -ge 1 ]]; then
	    	_remove_comp_word
	    elif [[ "$cmd" == -* ]] && [[ $COMP_CWORD -eq 0 ]]; then
	    	return
	    else
			done=1
	    fi
	done

	if [[ $COMP_CWORD -eq 0 ]]; then
		COMPREPLY=( $( compgen -c -- $cur ) )
	elif complete -p $cmd &>/dev/null; then
		cspec=$( complete -p $cmd )
		if [ "${cspec#* -F }" != "$cspec" ]; then
			# complete -F <function>
			#
			# COMP_CWORD and COMP_WORDS() are not read-only,
			# so we can set them before handing off to regular
			# completion routine

			# get function name
			func=${cspec#*-F }
			func=${func%% *}
			
			if [[ ${#COMP_WORDS[@]} -ge 2 ]]; then
				$func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}"	"${COMP_WORDS[${#COMP_WORDS[@]}-2]}"
			else
				$func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}"
			fi

			# remove any \: generated by a command that doesn't
			# default to filenames or dirnames (e.g. sudo chown)
			# FIXME: I'm pretty sure this does not work!
			if [ "${cspec#*-o }" != "$cspec" ]; then
				cspec=${cspec#*-o }
				cspec=${cspec%% *}
				if [[ "$cspec" != @(dir|file)names ]]; then
					COMPREPLY=("${COMPREPLY[@]//\\\\:/:}")
				fi
			fi
		elif [ -n "$cspec" ]; then
			cspec=${cspec#complete};
			cspec=${cspec%%$cmd};
			COMPREPLY=( $( eval compgen "$cspec" -- "$cur" ) );
		fi
	fi

	[ ${#COMPREPLY[@]} -eq 0 ] && _filedir
}
complete -F _command $filenames nohup exec nice eval strace time ltrace then \
	else do vsound command xargs tsocks

_root_command()
{
	PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin _command $1 $2 $3
}
complete -F _root_command $filenames sudo fakeroot really

# ImageMagick completion
#
have convert && {
_ImageMagick()
{
	local prev
	prev=${COMP_WORDS[COMP_CWORD-1]}

	case "$prev" in
		-channel)
			COMPREPLY=( $( compgen -W 'Red Green Blue Opacity \
				Matte Cyan Magenta Yellow Black' -- $cur ) )
			return 0
			;;
		-colormap)
			COMPREPLY=( $( compgen -W 'shared private' -- $cur ) )
			return 0
			;;
		-colorspace)
			COMPREPLY=( $( compgen -W 'GRAY OHTA RGB Transparent \
				XYZ YCbCr YIQ YPbPr YUV CMYK' -- $cur ) )
			return 0
			;;
		-compose)
			COMPREPLY=( $( compgen -W 'Over In Out Atop Xor Plus \
				Minus Add Subtract Difference Multiply Bumpmap\
				Copy CopyRed CopyGreen CopyBlue CopyOpacity' \
				-- $cur ) )
			return 0
			;;
		-compress)
			COMPREPLY=( $( compgen -W 'None BZip Fax Group4 JPEG \
				Lossless LZW RLE Zip' -- $cur ) )
			return 0
			;;
		-dispose)
			COMPREPLY=( $( compgen -W 'Undefined None Background \
						    Previous' -- $cur ) )
			return 0
			;;
		-encoding)
			COMPREPLY=( $( compgen -W 'AdobeCustom AdobeExpert \
				AdobeStandard AppleRoman BIG5 GB2312 Latin2 \
				None SJIScode Symbol Unicode Wansung' -- $cur))
			return 0
			;;
		-endian)
			COMPREPLY=( $( compgen -W 'MSB LSB' -- $cur ) )
			return 0
			;;
		-filter)
			COMPREPLY=( $( compgen -W 'Point Box Triangle Hermite \
				Hanning Hamming Blackman Gaussian Quadratic \
				Cubic Catrom Mitchell Lanczos Bessel Sinc' \
				-- $cur ) )
			return 0
			;;
		-format)
			COMPREPLY=( $( convert -list format | \
				    awk '/ [r-][w-][+-] / {print $1}' | \
				    tr -d '*' | tr [:upper:] [:lower:] | \
				    grep "^$cur" ) )
			return 0
			;;
		-gravity)
			COMPREPLY=( $( compgen -W 'Northwest North NorthEast \
				West Center East SouthWest South SouthEast' \
				-- $cur ) )
			return 0
			;;
		-intent)
			COMPREPLY=( $( compgen -W 'Absolute Perceptual \
					Relative Saturation' -- $cur ) )
			return 0
			;;
		-interlace)
			COMPREPLY=( $( compgen -W 'None Line Plane Partition' \
					-- $cur ) )
			return 0
			;;
		-limit)
			COMPREPLY=( $( compgen -W 'Disk File Map Memory' \
					-- $cur ) )
			return 0
			;;
		-list)
			COMPREPLY=( $( compgen -W 'Delegate Format Magic \
					Module Resource Type' -- $cur ) )
			return 0
			;;
		-map)
			COMPREPLY=( $( compgen -W 'best default gray red \
					green blue' -- $cur ) )
			_filedir
			return 0
			;;
		-noise)
			COMPREPLY=( $( compgen -W 'Uniform Gaussian \
					Multiplicative \
				Impulse Laplacian Poisson' -- $cur ) )
			return 0
			;;
		-preview)
			COMPREPLY=( $( compgen -W 'Rotate Shear Roll Hue \
					Saturation Brightness Gamma Spiff \
					Dull Grayscale Quantize Despeckle \
					ReduceNoise AddNoise Sharpen Blur \
					Treshold EdgeDetect Spread Shade \
					Raise Segment Solarize Swirl Implode \
					Wave OilPaint CharcoalDrawing JPEG' \
					-- $cur ) )
			return 0
			;;
		-@(mask|profile|texture|tile|write))
			_filedir
			return 0
			;;
		-type)
			COMPREPLY=( $( compgen -W 'Bilevel Grayscale Palette \
					PaletteMatte TrueColor TrueColorMatte \
					ColorSeparation ColorSeparationlMatte \
					Optimize' -- $cur ) )
			return 0
			;;
		-units)
			COMPREPLY=( $( compgen -W 'Undefined PixelsPerInch \
					PixelsPerCentimeter' -- $cur ) )
			return 0
			;;
		-virtual-pixel)
			COMPREPLY=( $( compgen -W 'Constant Edge mirror tile' \
					-- $cur ) )
			return 0
			;;
		-visual)
			COMPREPLY=( $( compgen -W 'StaticGray GrayScale \
					StaticColor PseudoColor TrueColor \
					DirectColor defaut visualid' -- $cur ))
			return 0
			;;
	esac
}

_convert()
{
	local cur

	COMPREPLY=()
	cur=`_get_cword`

	_ImageMagick

	if [[ "$cur" == -* ]]; then
		COMPREPLY=( $( compgen -W '-adaptive-blur -adaptive-resize \
			-adaptive-sharpen -adjoin -affine -alpha -annotate \
			-antialias -append -attenuate -authenticate \
			-auto-orient -average -background -bench -bias \
			-black-point-compensation -black-threshold \
			-blue-primary -blur -border -bordercolor -caption \
			-channel -charcoal -chop -clip -clip-mask -clip-path \
			-clone -clut -coalesce -colorize -colors -colorspace \
			-combine -comment -compose -composite -compress \
			-contrast -contrast-stretch -convolve -crop -cycle \
			-debug -decipher -deconstruct -define -delay -delete \
			-density -depth -despeckle -display -dispose -distort \
			-dither -draw -edge -emboss -encipher -encoding \
			-endian -enhance -equalize -evaluate -extent -extract \
			-family -fill -filter -flatten -flip -floodfill -flop \
			-font -format -frame -fuzz -fx -gamma -gaussian-blur \
			-geometry -gravity -green-primary -help -identify \
			-implode -insert -intent -interlace -interpolate \
			-label -lat -layers -level -limit -linear-stretch \
			-liquid-rescale -list -log -loop -map -mask \
			-mattecolor -median -modulate -monitor -monochrome \
			-morph -mosaic -motion-blur -negate -noise -normalize \
			-opaque -ordered-dither -orient -page -paint -ping \
			-pointsize -polaroid -posterize -preview -print \
			-process -profile -quality -quantize -quiet \
			-radial-blur -raise -random-threshold -recolor \
			-red-primary -regard-warnings -region -render -repage \
			-resample -resize -respect-parenthesis -reverse -roll \
			-rotate -sample -sampling-factor -scale -scene -seed \
			-segment -separate -sepia-tone -set -shade -shadow \
			-sharpen -shave -shear -sigmoidal-contrast -size \
			-sketch -solarize -splice -spread -stretch -strip \
			-stroke -strokewidth -style -swap -swirl -taint \
			-texture -threshold -thumbnail -tile -tile-offset \
			-tint -transform -transparent -transparent-color \
			-transpose -transverse -treedepth -trim -type \
			-undercolor -unique-colors -units -unsharp -verbose \
			-version -view -vignette -virtual-pixel -wave \
			-weight -white-point -white-threshold \
			-write' -- $cur ) )
	elif [[ "$cur" == +* ]]; then
		COMPREPLY=( $( compgen -W '+adjoin +append +compress \
			+contrast +debug +dither +endian +gamma +label +map \
			+mask +matte +negate +noise +page +raise +render \
			+write' -- $cur ) )
	else
		_filedir
	fi
}
complete -F _convert $filenames convert

_mogrify()
{
	local cur

	COMPREPLY=()
	cur=`_get_cword`

	_ImageMagick

	if [[ "$cur" == -* ]]; then
		COMPREPLY=( $( compgen -W '-adaptive-blur -adaptive-resize \
			-adaptive-sharpen -adjoin -affine -alpha -annotate \
			-antialias -attenuate -authenticate -auto-orient \
			-background -bias -black-point-compensation \
			-black-threshold -blue-primary -blur -border \
			-bordercolor -caption -channel -charcoal -chop -clip \
			-clip-mask -clip-path -clut -colorize -colors \
			-colorspace -comment -compose -compress -contrast \
			-contrast-stretch -convolve -cycle -debug -decipher \
			-define -delay -density -depth -despeckle -display \
			-dispose -distort -dither -draw -edge -emboss \
			-encipher -encoding -endian -enhance -equalize \
			-evaluate -extent -extract -family -fill -filter \
			-flip -floodfill -flop -font -format -frame -fuzz \
			-gamma -gaussian-blur -geometry -gravity \
			-green-primary -help -identify -implode -intent \
			-interlace -interpolate -label -lat -layers -level \
			-limit -linear-stretch -liquid-rescale -list -log \
			-loop -mask -mattecolor -median -modulate -monitor \
			-monochrome -motion-blur -negate -noise -normalize \
			-opaque -ordered-dither -orient -page -paint -path \
			-ping -pointsize -polaroid -posterize -preview -print \
			-profile -quality -quantize -quiet -radial-blur \
			-raise -random-threshold -recolor -red-primary \
			-regard-warnings -region -render -repage -resample \
			-resize -roll -rotate -sample -sampling-factor -scale \
			-scene -seed -segment -sepia-tone -set -shade -shadow \
			-sharpen -shave -shear -sigmoidal-contrast -size \
			-sketch -solarize -splice -spread -stretch -strip \
			-stroke -strokewidth -style -swirl -taint -texture \
			-threshold -thumbnail -tile -tile-offset -tint \
			-transform -transparent -transparent-color -transpose \
			-transverse -treedepth -trim -type -undercolor \
			-unique-colors -units -unsharp -verbose -version \
			-view -vignette -virtual-pixel -wave -weight \
			-white-point -white-threshold' -- $cur ) )
	elif [[ "$cur" == +* ]]; then
		COMPREPLY=( $( compgen -W '+compress +contrast +debug +dither \
			+endian +gamma +label +map +mask +matte +negate +page \
			+raise' -- $cur ) )
	else
		_filedir
	fi
}
complete -F _mogrify $filenames mogrify

_display()
{
	local cur

	COMPREPLY=()
	cur=`_get_cword`

	_ImageMagick

	if [[ "$cur" == -* ]]; then
		COMPREPLY=( $( compgen -W '-alpha -antialias -authenticate \
			-auto-orient -backdrop -background -border \
			-bordercolor -borderwidth -borderwidth -channel -clip \
			-clip-path -coalesce -colormap -colors -colorspace \
			-comment -compress -contrast -crop -debug -decipher \
			-define -delay -density -depth -despeckle -display \
			-dispose -dither -edge -endian -enhance -extract \
			-filter -flatten -flip -flop -font -foreground \
			-format -frame -gamma -geometry -help -iconGeometry \
			-iconic -identify -immutable -interlace -interpolate \
			-label -limit -list -log -loop -map -mattecolor \
			-monitor -monochrome -name -negate -page -profile \
			-quality -quantize -quiet -raise -regard-warnings \
			-remote -repage -resample -resize \
			-respect-parenthesis -roll -rotate -sample \
			-sampling-factor -scenes -seed -segment -set \
			-shared-memory -sharpen -size -strip -texture -title \
			-transparent-color -treedepth -trim -update \
			-usePixmap -verbose -version -virtual-pixel -visual \
			-window -window-group -write' -- $cur ) )
	elif [[ "$cur" == +* ]]; then
		COMPREPLY=( $( compgen -W '+compress +contrast +debug +dither \
			+endian +gamma +label +map +matte +negate +page \
			+raise +write' -- $cur ) )
	else
		_filedir
	fi
}
complete -F _display $filenames display

_animate()
{
	local cur

	COMPREPLY=()
	cur=`_get_cword`

	_ImageMagick

	if [[ "$cur" == -* ]]; then
		COMPREPLY=( $( compgen -W '-alpha -authenticate -backdrop \
			-background -bordercolor -borderwidth -channel \
			-coalesce -colormap -colors -colorspace -crop -debug \
			-decipher -define -delay -density -depth -display \
			-dispose -dither -extract -filter -flatten -font \
			-foreground -format -gamma -geometry -help \
			-iconGeometry -iconic -identify -immutable -interlace \
			-interpolate -limit -list -log -loop -map -mattecolor \
			-mattecolor -monitor -monochrome -name -page -pause \
			-quantize -quiet -regard-warnings -remote -repage \
			-resample -resize -respect-parenthesis -rotate \
			-sampling-factor -scenes -seed -set -shared-memory \
			-size -strip -title -transparent-color -treedepth \
			-trim -verbose -version -virtual-pixel -visual \
			-window' -- $cur ) )
	elif [[ "$cur" == +* ]]; then
		COMPREPLY=( $( compgen -W '+debug +dither +gamma +map +matte' -- $cur ) )
	else
		_filedir
	fi
}
complete -F _animate $filenames animate

_identify()
{
	local cur

	COMPREPLY=()
	cur=`_get_cword`

	_ImageMagick

	if [[ "$cur" == -* ]]; then
		COMPREPLY=( $( compgen -W '-alpha -antialias -authenticate \
			-channel -colorspace -crop -debug -define -density \
			-depth -extract -format -fuzz -gamma -help -interlace \
			-interpolate -limit -list -log -monitor -ping -quiet \
			-regard-warnings -respect-parenthesis \
			-sampling-factor -seed -set -size -strip -units \
			-verbose -version -virtual-pixel' -- $cur ) )
	elif [[ "$cur" == +* ]]; then
		COMPREPLY=( $( compgen -W '+debug' -- $cur ) )
	else
		_filedir
	fi
}
complete -F _identify $filenames identify

_montage()
{
	local cur

	COMPREPLY=()
	cur=`_get_cword`

	_ImageMagick

	if [[ "$cur" == -* ]]; then
		COMPREPLY=( $( compgen -W '-adjoin -affine -alpha \
			-authenticate -background -blue-primary -blur -border \
			-bordercolor -borderwidth -caption -channel -clone \
			-coalesce -colors -colorspace -comment -compose \
			-compress -crop -debug -define -density -depth \
			-display -dispose -dither -draw -encoding -endian \
			-extract -fill -filter -flatten -flip -flop -font \
			-format -frame -gamma -geometry -gravity \
			-green-primary -help -identify -interlace \
			-interpolate -label -limit -list -log -mattecolor \
			-mode -monitor -monochrome -origin -page -pointsize \
			-polaroid -profile -quality -quantize -quiet \
			-red-primary -regard-warnings -repage -resize \
			-respect-parenthesis -rotate -sampling-factor -scenes \
			-seed -set -shadow -size -strip -stroke -texture \
			-thumbnail -tile -title -transform -transparent \
			-transparent-color -treedepth -trim -type -units \
			-verbose -version -virtual-pixel \
			-white-point' -- $cur ) )
	elif [[ "$cur" == +* ]]; then
		COMPREPLY=( $( compgen -W '+adjoin +compress +debug +dither \
			+endian +gamma +label +matte +page' -- $cur ) )
	else
		_filedir
	fi
}
complete -F _montage $filenames montage

_composite()
{
	local cur

	COMPREPLY=()
	cur=`_get_cword`

	_ImageMagick

	if [[ "$cur" == -* ]]; then
		COMPREPLY=( $( compgen -W '-affine -alpha -authenticate \
			-blend -blue-primary -border -bordercolor -channel \
			-colors -colorspace -comment -compose -compress \
			-debug -decipher -define -density -depth -displace \
			-display -dispose -dissolve -dither -encipher \
			-encoding -endian -extract -filter -font -format \
			-geometry -gravity -green-primary -help -identify \
			-interlace -interpolate -label -limit -list -log \
			-monitor -monochrome -negate -page -profile -quality \
			-quantize -quiet -red-primary -regard-warnings \
			-repage -resize -respect-parenthesis -rotate \
			-sampling-factor -scene -seed -sharpen -shave -size \
			-stegano -stereo -strip -swap -thumbnail -tile \
			-transform -transparent-color -treedepth -type -units \
			-unsharp -verbose -version -virtual-pixel -watermark \
			-white-point -write' -- $cur ) )
	elif [[ "$cur" == +* ]]; then
		COMPREPLY=( $( compgen -W '+compress +debug +dither +endian +label \
			+matte +negate +page +write' -- $cur ) )
	else
		_filedir
	fi
}
complete -F _composite $filenames composite

_compare()
{
	local cur

	COMPREPLY=()
	cur=`_get_cword`

	_ImageMagick

	if [[ "$cur" == -* ]]; then
		COMPREPLY=( $( compgen -W '-alpha -authenticate -channel \
			-colorspace -compress -debug -decipher -define \
			-density -depth -encipher -extract -format -fuzz \
			-help -highlight-color -identify -interlace -limit \
			-list -log -metric -monitor -passphrase -profile \
			-quality -quantize -quiet -regard-warnings \
			-respect-parenthesis -sampling-factor -seed -set \
			-size -transparent-color -type -verbose -version \
			-virtual-pixel' -- $cur ) )
	elif [[ "$cur" == +* ]]; then
		COMPREPLY=( $( compgen -W '+debug' -- $cur ) )
	else
		_filedir
	fi
}
complete -F _compare $filenames compare

_conjure()
{
	local cur

	COMPREPLY=()
	cur=`_get_cword`

	_ImageMagick

	if [[ "$cur" == -* ]]; then
		COMPREPLY=( $( compgen -W '-debug -help -list -log -monitor \
			-quiet -regard-warnings -seed -verbose \
			-version' -- $cur ) )
	elif [[ "$cur" == +* ]]; then
		COMPREPLY=( $( compgen -W '+debug' -- $cur ) )
	else
		_filedir
	fi
}
complete -F _conjure $filenames conjure

_import()
{
	local cur

	COMPREPLY=()
	cur=`_get_cword`

	_ImageMagick

	if [[ "$cur" == -* ]]; then
		COMPREPLY=( $( compgen -W '-adjoin -annotate -border -channel \
			-colors -colorspace -comment -compress -crop -debug \
			-define -delay -density -depth -descend -display \
			-dispose -dither -encipher -encoding -endian -filter \
			-format -frame -geometry -gravity -help -identify \
			-interlace -interpolate -label -limit -list -log \
			-monitor -monochrome -negate -page -pause -pointsize \
			-quality -quantize -quiet -regard-warnings -repage \
			-resize -respect-parenthesis -rotate -sampling-factor \
			-scene -screen -seed -set -silent -snaps -strip \
			-thumbnail -transparent -transparent-color -treedepth \
			-trim -type -verbose -version -virtual-pixel \
			-window' -- $cur ) )
	elif [[ "$cur" == +* ]]; then
		COMPREPLY=( $( compgen -W '+debug' -- $cur ) )
	else
		_filedir
	fi
}
complete -F _import $filenames import

_stream()
{
	local cur

	COMPREPLY=()
	cur=`_get_cword`

	_ImageMagick

	if [[ "$cur" == -* ]]; then
		COMPREPLY=( $( compgen -W '-authenticate -channel -colorspace \
			-compress -debug -define -density -depth -extract \ 
			-help -identify -interlace -interpolate -limit -list \
			-log -map -monitor -quantize -quiet -regard-warnings \
			-respect-parenthesis -sampling-factor -seed -set \
			-size -storage-type -transparent-color -verbose \
			-version -virtual-pixel' -- $cur ) )
	elif [[ "$cur" == +* ]]; then
		COMPREPLY=( $( compgen -W '+debug' -- $cur ) )
	else
		_filedir
	fi
}
complete -F _stream $filenames stream
}

# svn completion
#
have svn &&
{
_svn()
{
	local cur prev commands options command

	COMPREPLY=()
	cur=`_get_cword`

	commands='add blame praise annotate ann cat checkout co cleanup commit \
		ci copy cp delete del remove rm diff di export help ? h import \
		info list ls lock log merge mkdir move mv rename ren \
		propdel pdel pd propedit pedit pe propget pget pg \
		proplist plist pl propset pset ps resolved revert \
		status stat st switch sw unlock update up'

	if [[ $COMP_CWORD -eq 1 ]] ; then
		if [[ "$cur" == -* ]]; then
			COMPREPLY=( $( compgen -W '--version' -- $cur ) )
		else
			COMPREPLY=( $( compgen -W "$commands" -- $cur ) )
		fi
	else

		prev=${COMP_WORDS[COMP_CWORD-1]}
		case $prev in
			--config-dir)
				_filedir -d
				return 0;
				;;
			-@(F|-file|-targets))
				_filedir
				return 0;
				;;
			--encoding)
				COMPREPLY=( $( compgen -W \
					'$( iconv --list | sed -e "s@//@@;" )' \
					-- "$cur" ) )
				return 0;
				;;
			--@(editor|diff|diff3)-cmd)
				COMP_WORDS=(COMP_WORDS[0] $cur)
				COMP_CWORD=1
				_command
				return 0;
				;;
		esac

		command=${COMP_WORDS[1]}

		if [[ "$cur" == -* ]]; then
			# possible options for the command
			case $command in
				add)
					options='--auto-props --no-auto-props \
						--force --targets --no-ignore \
						--non-recursive -N -q --quiet'
					;;
				@(blame|annotate|ann|praise))
					options='-r --revisions --username \
						--password --no-auth-cache \
						--non-interactive -v \
						--verbose --incremental --xml'
					;;
				cat)
					options='-r --revision --username \
						--password --no-auth-cache \
						--non-interactive'
					;;
				@(checkout|co))
					options='-r --revision -q --quiet -N \
						--non-recursive --username \
						--password --no-auth-cache \
						--non-interactive \
						--ignore-externals'
					;;
				cleanup)
					options='--diff3-cmd'
					;;
				@(commit|ci))
					options='-m --message -F --file \
						--encoding --force-log -q \
						--quiet --non-recursive -N \
						--targets --editor-cmd \
						--username --password \
						--no-auth-cache \
						--non-interactive --no-unlock'
					;;
				@(copy|cp))
					options='-m --message -F --file \
						--encoding --force-log -r \
						--revision -q --quiet \
						--editor-cmd -username \
						--password --no-auth-cache \
						--non-interactive'
					;;
				@(delete|del|remove|rm))
					options='--force -m --message -F \
						--file --encoding --force-log \
						-q --quiet --targets \
						--editor-cmd -username \
						--password --no-auth-cache \
						--non-interactive'
					;;
				@(diff|di))
					options='-r --revision -x --extensions \
						--diff-cmd --no-diff-deleted \
						-N --non-recursive --username \
						--password --no-auth-cache \
						--non-interactive --force \
						--old --new --notice-ancestry'
					;;
				export)
					options='-r --revision -q --quiet \
						--username --password \
						--no-auth-cache \
						--non-interactive -N \
						--non-recursive --force \
						--native-eol --ignore-externals'
					;;
				import)
					options='--auto-props --no-auto-props \
						-m --message -F --file \
						--encoding --force-log -q \
						--quiet --non-recursive \
						--no-ignore --editor-cmd \
						--username --password \
						--no-auth-cache \
						--non-interactive'
					;;
				info)
					options='--username --password \
						--no-auth-cache \
						--non-interactive -r \
						--revision --xml --targets \
						-R --recursive --incremental'
					;;
				@(list|ls))
					options='-r --revision -v --verbose -R \
						--recursive --username \
						--password --no-auth-cache \
						--non-interactive \
						--incremental --xml'
					;;
				lock)
					options='-m --message -F --file \
						--encoding --force-log \
						--targets --force --username \
						--password --no-auth-cache \
						--non-interactive'
					;;
				log)
					options='-r --revision -v --verbose \
						--targets --username \
						--password --no-auth-cache \
						--non-interactive \
						--stop-on-copy --incremental \
						--xml -q --quiet --limit'
					;;
				merge)
					options='-r --revision -N \
						--non-recursive -q --quiet \
						--force --dry-run --diff3-cmd \
						--username --password \
						--no-auth-cache \
						--non-interactive \
						--ignore-ancestry'
					;;
				mkdir)
					options='-m --message -F --file \
						--encoding --force-log -q \
						--quiet --editor-cmd \
						--username --password \
						--no-auth-cache \
						--non-interactive'
					;;
				@(move|mv|rename|ren))
					options='-m --message -F --file \
						--encoding --force-log -r \
						--revision -q --quiet \
						--force --editor-cmd \
						--username --password \
						--no-auth-cache \
						--non-interactive'
					;;
				@(propdel|pdel|pd))
					options='-q --quiet -R --recursive -r \
						--revision --revprop \
						--username --password \
						--no-auth-cache \
						--non-interactive'
					;;
				@(propedit|pedit|pe))
					options='-r --revision --revprop \
						--encoding --editor-cmd \
						--username --password \
						--no-auth-cache \
						--non-interactive --force'
					;;
				@(propget|pget|pg))
					options='-R --recursive -r --revision \
						--revprop --strict --username \
						--password --no-auth-cache \
						--non-interactive'
					;;
				@(proplist|plist|pl))
					options='-v --verbose -R --recursive \
						-r --revision --revprop -q \
						--quiet --username --password \
						--no-auth-cache \
						--non-interactive'
					;;
				@(propset|pset|ps))
					options='-F --file -q --quiet \
						--targets -R --recursive \
						--revprop --encoding \
						--username --password \
						--no-auth-cache \
						--non-interactive -r \
						--revision --force'
					;;
				resolved)
					options='--targets -R --recursive -q \
						--quiet'
					;;
				revert)
					options='--targets -R --recursive -q \
						--quiet'
					;;
				@(status|stat|st))
					options='-u --show-updates -v \
						--verbose -N --non-recursive \
						-q --quiet --username \
						--password --no-auth-cache \
						--non-interactive --no-ignore \
						--ignore-externals \
						--incremental --xml'
					;;
				@(switch|sw))
					options='--relocate -r --revision -N \
						--non-recursive -q --quiet \
						--username --password \
						--no-auth-cache \
						--non-interactive --diff3-cmd'
					;;
				unlock)
					options='--targets --force --username \
						--password --no-auth-cache \
						--non-interactive'
					;;
				@(update|up))
					options='-r --revision -N \
						--non-recursive -q --quiet \
						--username --password \
						--no-auth-cache \
						--non-interactive \
						--diff3-cmd --ignore-externals'
					;;
			esac
			options="$options --help -h --config-dir"

			COMPREPLY=( $( compgen -W "$options" -- $cur ) )
		else
			if [[ "$command" == @(help|h|\?) ]]; then
				COMPREPLY=( $( compgen -W "$commands" -- $cur ) )
			else
				_filedir
			fi
		fi
	fi

	return 0
}
complete -F _svn $default svn

_svnadmin()
{
	local cur prev commands options mode

	COMPREPLY=()
	cur=`_get_cword`

	commands='create deltify dump help ? hotcopy list-dblogs \
		list-unused-dblogs load lslocks lstxns recover rmlocks \
		rmtxns setlog verify'

	if [[ $COMP_CWORD -eq 1 ]] ; then
		if [[ "$cur" == -* ]]; then
			COMPREPLY=( $( compgen -W '--version' -- $cur ) )
		else
			COMPREPLY=( $( compgen -W "$commands" -- $cur ) )
		fi
	else
		prev=${COMP_WORDS[COMP_CWORD-1]}
		case $prev in
			--config-dir)
				_filedir -d
				return 0;
				;;
			--fs-type)
				COMPREPLY=( $( compgen -W 'fsfs bdb' -- $cur ) )
				return 0;
				;;
		esac

		command=${COMP_WORDS[1]}

		if [[ "$cur" == -* ]]; then
			# possible options for the command
			case $command in
				create)
					options='--bdb-txn-nosync \
						--bdb-log-keep --config-dir \
						--fs-type'
					;;
				deltify)
					options='-r --revision -q --quiet'
					;;
				dump)
					options='-r --revision --incremental \
						-q --quiet --deltas'
					;;
				hotcopy)
					options='--clean-logs'
					;;
				load)
					options='--ignore-uuid --force-uuid \
						--parent-dir -q --quiet \
						--use-pre-commit-hook \
						--use-post-commit-hook'
					;;
				rmtxns)
					options='-q --quiet'
					;;
				setlog)
					options='-r --revision --bypass-hooks'
					;;
			esac

			options="$options --help -h"
			COMPREPLY=( $( compgen -W "$options" -- $cur ) )
		else
			if [[ "$command" == @(help|h|\?) ]]; then
				COMPREPLY=( $( compgen -W "$commands" -- $cur ) )
			else
				_filedir
			fi
		fi
	fi

	return 0
}
complete -F _svnadmin $default svnadmin

_svnlook()
{
	local cur prev commands options mode

	COMPREPLY=()
	cur=`_get_cword`

	commands='author cat changed date diff dirs-changed help ? h history \
		info lock log propget pget pg proplist plist pl tree uuid \
		youngest'

	if [[ $COMP_CWORD -eq 1 ]] ; then
		if [[ "$cur" == -* ]]; then
			COMPREPLY=( $( compgen -W '--version' -- $cur ) )
		else
			COMPREPLY=( $( compgen -W "$commands" -- $cur ) )
		fi
	else
		command=${COMP_WORDS[1]}

		if [[ "$cur" == -* ]]; then
			# possible options for the command
			case $command in
				@(author|cat|date|dirs-changed|info|log))
					options='-r --revision -t \
						--transaction'
					;;
				changed)
					options='-r --revision -t \
						--transaction --copy-info'
					;;
				diff)
					options='-r --revision -t \
						--transaction \
						--no-diff-deleted \
						--no-diff-added \
						--diff-copy-from'
					;;
				history)
					options='-r --revision --show-ids'
					;;
				prop@(get|list))
					options='-r --revision -t \
						--transaction --revprop'
					;;
				tree)
					options='-r --revision -t \
						--transaction --show-ids \
						--full-paths'
					;;
			esac

			options="$options --help -h"
			COMPREPLY=( $( compgen -W "$options" -- $cur ) )
		else
			if [[ "$command" == @(help|h|\?) ]]; then
				COMPREPLY=( $( compgen -W "$commands" -- $cur ) )
			else
				_filedir
			fi
		fi
	fi

	return 0
}
complete -F _svnlook $default svnlook
}

# source completion directory definitions
if [ -d $BASH_COMPLETION_DIR -a -r $BASH_COMPLETION_DIR -a \
     -x $BASH_COMPLETION_DIR ]; then
	for i in $BASH_COMPLETION_DIR/*; do
		[[ ${i##*/} != @(*~|*.bak|*.swp|\#*\#|*.dpkg*|*.rpm@(orig|new|save)) ]] &&
			[ \( -f $i -o -h $i \) -a -r $i ] && . $i
	done
fi
unset i
